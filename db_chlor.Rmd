---
title: "Untitled"
author: "Pierre Chrislin DORIVAL"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
library(dplyr)
#install.packages("purrr")
library(viridis)
#install.packages("ggpubr")
#install.packages("factoextra")
library(RColorBrewer)
#install.packages("fmsb")
library(fmsb)
library(ggplot2)
library(tidyr)
library(rstatix)
library(sf)
library(ggmap)
# Charger la librairie caret
library(caret)
library(stats)
library(reshape2)
library(purrr)
library(ggpubr)
library(factoextra)

```

```{r}
db_chlor = parcelles_chlordecone_janv21
db_chlor
```
```{r}
db_chlor = parcelles_chlordecone_janv21
# Extraire la première ligne comme noms de colonnes
noms_colonnes <- as.character(db_chlor[1, ])

# Remplacer les noms de colonnes
colnames(db_chlor) <- noms_colonnes

# Supprimer la première ligne des données
db_chlor <- db_chlor[-1, ]

rownames(db_chlor) <- NULL

# Afficher les premières lignes des données avec les nouveaux noms de colonnes
head(db_chlor)

```
```{r}
# Compter le nombre de valeurs NA dans la colonne COMMU_LAB
nb_na <- sum(is.na(db_chlor$COMMU_LAB))
nb_na



```




```{r}
colnames(db_chlor)
```
```{r}
db_chlor$COMMU_LAB[is.na(db_chlor$COMMU_LAB)] <- "COMMU_UN"
db_chlor <- subset(db_chlor, COMMU_LAB != "COMMU_UN")
db_chlor <- subset(db_chlor, Adresse_parcelle != "")
supprimer_colonnes_na <- function(data) {
  # Identifier les colonnes avec au moins une valeur NA
  colonnes_a_supprimer <- names(data)[apply(data, 2, function(x) any(is.na(x)))]
  
  # Supprimer les colonnes identifiées
  data <- data[, !(names(data) %in% colonnes_a_supprimer)]
  
  return(data)
}



new_db_chlor <- supprimer_colonnes_na(db_chlor)


# Afficher les premières lignes des données après suppression des colonnes
new_db_chlor


```
```{r}

# Preparation des donnees
colnames(new_db_chlor)[colnames(new_db_chlor) == "pluviom\xe9trie_moyenne_annuelle"] <- "pluviometrie_moyenne_annuelle"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_mean"] <- "mnt.rugosite_mean"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_median"] <- "mnt.rugosite_median"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_stdev"] <- "mnt.rugosite_stdev"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_min"] <- "mnt.rugosite_min"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_max"] <- "mnt.rugosite_max"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_minority"] <- "mnt.rugosite_minority"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_majority"] <- "mnt.rugosite_majority"

colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_variance"] <- "mnt.rugosite_variance"
colnames(new_db_chlor)[colnames(new_db_chlor) == "Ann\xe9e"] <- "Annee"
new_db_chlor$Adresse_parcelle <- iconv(new_db_chlor$Adresse_parcelle, from = "UTF-8", to = "ASCII", sub = "e")

new_db_chlor$pluviometrie_moyenne_annuelle <- gsub("-",  "+",new_db_chlor$pluviometrie_moyenne_annuelle)


# transformer les donnees dans la colonnes pulviometrie
moyennes <- numeric(length(new_db_chlor$pluviometrie_moyenne_annuelle))

# Diviser chaque valeur et calculer la moyenne
for(i in 1:length(new_db_chlor$pluviometrie_moyenne_annuelle)) {
    # Diviser la valeur en deux parties en utilisant le symbole '+'
    valeurs <- strsplit(new_db_chlor$pluviometrie_moyenne_annuelle[i], "\\+")
    # Convertir les parties en nombres et calculer la moyenne
    moyennes[i] <- mean(as.numeric(unlist(valeurs)))
}
new_db_chlor$Date_prelevement <- as.Date(new_db_chlor$Date_prelevement, format = "%d/%m/%Y")
# Ajouter la colonne de moyennes au jeu de données
new_db_chlor$moyenne_pulviometrie <- moyennes

new_db_chlor <- new_db_chlor[, !colnames(new_db_chlor) %in% c("Numero_sig", "ocs_gid", "ocs_code_us","ocs_ossature","ocs_code_cs","ocs_millesime","ocs_source","ocs_id_origine","ocs_code_or","Interet","pluviometrie_moyenne_annuelle","Operateur_5b","Operateur_chld")]

# Écrire les données modifiées dans un nouveau fichier CSV
write.csv(new_db_chlor, "new_db_chlordecone.csv", row.names = FALSE)

```
```{r}

nlle_table <- new_db_chlordecone[, c("COMMU_LAB", "mnt.exposition_mean", "mnt.ombrage_mean","mnt.tri_mean","mnt.tpi_mean","Taux_chlordecone")] 
nlle_table$Taux_chlordecone <- as.numeric(nlle_table$Taux_chlordecone)

#nlle_table$mnt.ombrage_mean <- as.numeric(nlle_table$mnt.ombrage_mean)
nlle_table



```

```{r}
# Analyse statistiques


data_parcelle <- new_db_chlordecone[, c("Adresse_parcelle", "Taux_chlordecone")]

# Agrégation des données par commune (calcul de la moyenne)
mean_parcelle <- aggregate(Taux_chlordecone ~ Adresse_parcelle, data = data_parcelle, FUN = mean)



# Génération de 35 couleurs distinctes à partir de la palette
couleurs <- rainbow(35)
# Création du graphique (exemple avec un diagramme en barres)
barplot(mean_parcelle$Taux_chlordecone, 
        names.arg = mean_parcelle$Adresse_parcelle, 
        col = couleurs, # Utilisation des couleurs variables
        xlab = "Commune", 
        ylab = "Taux moyen de chlordecone",
        main = "Répartition des taux de chlordecone par parcelle")

legend("topright", 
       legend = mean_parcelle$Adresse_parcelle, 
       fill = couleurs, 
       title = "Communes",
       text.col = "black",   
       cex = 0.1) 
```
```{r}
unique(new_db_chlordecone$COMMU_LAB)
```

```{r}
# Création du graphique boxplot avec les données des taux de chlordecone par commune
boxplot(Taux_chlordecone ~ COMMU_LAB, data = data_commu, 
        xlab = "Commune", 
        ylab = "Taux de chlordecone",
        main = "Répartition des taux de chlordecone par commune")


```



```{r}
hist(mean_commu$Taux_chlordecone, 
     xlab = "Taux de chlordecone",
     ylab = "Fréquence",
     main = "Distribution des taux de chlordecone")
```
```{r}
colnames(new_db_chlordecone)
```
```{r}
nlle_table <- new_db_chlordecone[, c("COMMU_LAB", "Date_enregistrement", "Adresse_parcelle","Taux_chlordecone")] 
nlle_table

unique(new_db_chlordecone$Adresse_parcelle)
```
```{r}
new_db_chlordecone$Date_prelevement <- as.Date(new_db_chlordecone$Date_prelevement)




# Créer un résumé du nombre de parcelles par ville
res <- new_db_chlordecone %>% 
  group_by(COMMU_LAB) %>%
  summarize(Count = n())

# Tracer un diagramme en barres
ggplot(res, aes(x = reorder(COMMU_LAB, Count), y = Count)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(x = "Ville", y = "Nombre de parcelles", title = "Nombre de parcelles par ville") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_flip()

```
```{r}
res <- new_db_chlordecone %>%
  group_by(Date_prelevement) %>%
  summarize(Nombre_ID = n_distinct(ID))

# Tracer un graphique en barres
ggplot(res, aes(x = Date_prelevement, y = Nombre_ID)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(x = "Date de prélèvement", y = "Nombre d'ID", title = "Répartition des ID par date de prélèvement") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")
```
```{r}
repetitions_ID_dates <- new_db_chlordecone %>%
  group_by(Annee, COMMU_LAB) %>%
  summarize(Count = n(), .groups = "drop")
repetitions_ID_dates
```
```{r}
```


```{r}
unique(new_db_chlordecone$Adresse_parcelle)

nombre_villes_par_annee <- new_db_chlordecone %>%
  distinct(Annee,Adresse_parcelle) %>%
  group_by(Annee) %>%
  summarize(Nombre_Villes_Uniques = n_distinct(Adresse_parcelle))
nombre_villes_par_annee

```
```{r}
combinaisons <- new_db_chlordecone %>%
  distinct(Annee, Adresse_parcelle)

# Créer une liste des villes pour chaque année
liste_villes_par_annee <- combinaisons %>%
  group_by(Annee) %>%
  summarize(Adresse_parcelle = paste(Adresse_parcelle, collapse = ", "))

# Afficher le résultat
liste_villes_par_annee
```


```{r}

ggplot(data = donnees_ville, aes(x = Annee, y = Taux_chlordecone)) +
  geom_bar(stat = "identity", fill = "blue") +
  labs(title = "Variation des taux de chlordécone Lamentin", x = "Année", y = "Taux de chlordécone")

```
```{r}
ggplot(data = donnees_ville, aes(x = Taux_chlordecone)) +
  geom_histogram(binwidth = 1, fill = "blue", color = "black") +
 facet_wrap(~Annee, scales = "free", ncol = 3) +
  labs(title = paste("Répartition des taux de chlordécone pour la ville", "LAMENTIN(LE)", "au fil des années"), x = "Taux de chlordécone", y = "Fréquence")
```
```{r}
# Création du modèle de régression
modele <- lm(Taux_chlordecone ~ Annee, data = new_db_chlordecone)

# Prédictions
predictions <- data.frame(Annee = rep(unique(new_db_chlordecone$Annee), length(unique(new_db_chlordecone$Adresse_parcelle))),
                         Adresse_parcelle = rep(unique(new_db_chlordecone$Adresse_parcelle), each = length(unique(new_db_chlordecone$Annee))))
predictions$Taux_chlordecone <- predict(modele, newdata = predictions)

# Chargement du package ggplot2
library(ggplot2)

# Création du graphique
graphique <- ggplot(data = new_db_chlordecone, aes(x = Annee, y = Taux_chlordecone, color = Adresse_parcelle)) +
  geom_point() +
  geom_line(data = predictions) +
  labs(title = "Répartition des taux de chlordécone pour commune au fil des années",
       x = "Année",
       y = "Taux de chlordécone",
       color = "Adresse_parcelle")
graphique
# Sauvegarde du graphique avec les dimensions spécifiées
#ggsave("nom_du_fichier.png", plot = graphique, width = 6, height = 4)
```
```{r}
# Création du modèle de régression
modele <- lm(Taux_chlordecone ~ Annee, data = new_db_chlordecone)

# Prédictions
predictions <- data.frame(Annee = rep(unique(new_db_chlordecone$Annee), length(unique(new_db_chlordecone$Adresse_parcelle))),
                         Adresse_parcelle = rep(unique(new_db_chlordecone$Adresse_parcelle), each = length(unique(new_db_chlordecone$Annee))))
predictions$Taux_chlordecone <- predict(modele, newdata = predictions)

# Tracé du graphique de régression
plot(new_db_chlordecone$Annee, new_db_chlordecone$Taux_chlordecone, 
     xlab = "Année", ylab = "Taux de chlordécone",
     main = "Répartition des taux de chlordécone pour commune au fil des années",
     col = "blue", pch = 20)
abline(modele, col = "red")  # Ajout de la ligne de régression

# Ajout de la légende
legend("topright", legend = "Régression linéaire", col = "red", lty = 1, cex = 0.8)


```
```{r}


# Diviser les données en ensembles d'entraînement et de test (par exemple, 70% pour l'entraînement et 30% pour les tests)
set.seed(123) # pour la reproductibilité
indices <- createDataPartition(new_db_chlordecone$Taux_chlordecone, p = 0.7, list = FALSE)
train <- new_db_chlordecone[indices, ]
test <- new_db_chlordecone[-indices, ]

# Créer le modèle de régression linéaire
modele <- lm(Taux_chlordecone ~ Annee, data = train)

# Afficher un résumé du modèle
summary(modele)
```
```{r}
# Faire des prédictions sur l'ensemble de test
predictions <- predict(modele, newdata = test)

# Calculer l'erreur quadratique moyenne (RMSE)
rmse <- sqrt(mean((predictions - test$Taux_chlordecone)^2))
print(paste("RMSE:", rmse))

```
```{r}
# Choix du nombre de clusters (k)
k <- 2  # Vous pouvez ajuster cette valeur selon votre contexte

# Sélection des variables pertinentes pour le clustering
donnees_clustering <- new_db_chlordecone[, c("Annee", "Taux_chlordecone")]

# Application de la méthode des k-moyennes
kmeans_resultats <- kmeans(donnees_clustering, centers = k)

# Affichage des résultats
print(kmeans_resultats)

# Visualisation des clusters
library(ggplot2)
ggplot(donnees_clustering, aes( x = Taux_chlordecone,y = Annee, color = factor(kmeans_resultats$cluster))) +
  geom_point() +
  labs(title = "Clustering des données de chlordécone",
       x = "Année",
       y = "Taux de chlordécone",
       color = "Cluster") +
  theme_minimal()
```

```{r}

k <- 3  # Vous pouvez ajuster cette valeur selon votre contexte

# Sélection des variables pertinentes pour le clustering
donnees_clustering <- new_db_chlordecone[, c( "Annee", "Taux_chlordecone")]

# Application de la méthode des k-moyennes
kmeans_resultats <- kmeans(donnees_clustering, centers = k)

# Affichage des résultats
print(kmeans_resultats)

# Visualisation des clusters
library(ggplot2)
ggplot(donnees_clustering, aes(x = Annee, y = Taux_chlordecone, color = factor(kmeans_resultats$cluster))) +
  geom_point() +
  labs(title = "Clustering des données de chlordécone",
       x = "Année",
       y = "Taux de chlordécone",
       color = "Cluster") +
  theme_minimal()
```


```{r}
plot(new_db_chlordecone$Annee, new_db_chlordecone$Taux_chlordecone, xlab = "Année", ylab = "Taux de chlordécone", type = "l")

# Graphique de la distribution des taux de chlordécone par commune
boxplot(Taux_chlordecone ~ COMMU_LAB, data = new_db_chlordecone, xlab = "Commune", ylab = "Taux de chlordécone")

```





```{r}

adresses_ville <- new_db_chlordecone$Adresse_parcelle[new_db_chlordecone$COMMU_LAB == "LAMENTIN(LE)"]


nlle_table <- new_db_chlordecone[, c("Adresse_parcelle","Annee")] 
nlle_table

# Regrouper les données par commune et obtenir une liste des adresses de parcelles pour chaque commune
adresses_par_commune <- new_db_chlordecone %>%
  group_by(Adresse_parcelle) %>%
  summarize(adresses_parcelles = paste(Annee, collapse = ","))

# Afficher les adresses des parcelles pour chaque commune
adresses_par_commune

```
```{r}
qqnorm(new_db_chlordecone$Taux_chlordecone)
hist(new_db_chlordecone$Taux_chlordecone,main="",xlab="")

```

```{r}
# Grouper les données par adresse de parcelle et calculer les variations du taux de chlordécone d'une année à l'autre
resultats <- new_db_chlordecone %>%
  group_by(Adresse_parcelle) %>%
  mutate(variation = Taux_chlordecone - lag(Taux_chlordecone)) %>%
  filter(!is.na(variation)) %>%
  mutate(decroissance = ifelse(variation < 0, TRUE, FALSE)) %>%
  select(Adresse_parcelle, Annee, decroissance)
resultats 
# Afficher les années où le taux de chlordécone décroît pour chaque adresse de parcelle
resultats_decroissance <- resultats %>%
  filter(decroissance == TRUE) %>%
  group_by(Adresse_parcelle) %>%
  summarize(Annees_decroissance = toString(unique(Annee)))

resultats_decroissance
```
```{r}


# Filtrer les adresses de parcelles où le taux de chlordécone décroît pour toutes les années
adresses_decroissantes <- resultats %>%
  group_by(Adresse_parcelle) %>%
  summarise(decroissance_total = all(decroissance))

# Filtrer les adresses de parcelles où le taux de chlordécone croît pour toutes les années
adresses_croissantes <- resultats %>%
  filter(decroissance == FALSE) %>%
  group_by(Adresse_parcelle) %>%
  summarise(croissance_total = all(!decroissance))

# Fusionner les deux ensembles de données
adresses_clusters <- full_join(adresses_decroissantes, adresses_croissantes, by = "Adresse_parcelle") %>%
  replace(is.na(.), FALSE)  # Remplacer les NA par FALSE

# Appliquer le clustering K-means
set.seed(123)  # Pour la reproductibilité des résultats
kmeans_cluster <- kmeans(adresses_clusters[, -1], centers = 2)  # Cluster binaire, croissance et décroissance
kmeans_cluster
# Visualiser les clusters
adresses_clusters$cluster <- as.factor(kmeans_cluster$cluster)
adresses_clusters_plot <- adresses_clusters %>%
  pivot_longer(cols = c(decroissance_total, croissance_total)) %>%
  ggplot(aes(x = name, y = Adresse_parcelle, fill = factor(value))) +
  geom_tile() +
  labs(title = "Clusters des adresses de parcelles",
       x = NULL,
       y = NULL,
       fill = NULL) +
  scale_fill_manual(values = c("yellow", "blue")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 10, vjust = 0.5, hjust=1))

adresses_clusters_plot


```

```{r}
adresses_crois <- resultats %>%
  filter(decroissance == FALSE) %>%
  group_by(Adresse_parcelle) %>%
summarize(Annees_croissance = toString(unique(Annee)))

 
adresses_crois
```
```{r}
library(dplyr)

# Regrouper les données par commune et obtenir une liste des adresses de parcelles pour chaque commune
adresses_par_commune <- new_db_chlordecone %>%
  group_by(COMMU_LAB) %>%
  summarize(adresses_parcelles = paste(Adresse_parcelle, collapse = ""))

# Afficher les adresses des parcelles pour chaque commune
adresses_par_commune

parcelles_par_commune <- adresses_par_commune %>%
  filter(COMMU_LAB == "DUCOS")

# Afficher les adresses des parcelles pour la commune spécifique
parcelles_par_commune$adresses_parcelles


```
```{r}
taux_chl<- data.frame(new_db_chlordecone$Annee, new_db_chlordecone$Taux_chlordecone)
cluster_1 <- kmeans(taux_chl, centers = 7)
summary(cluster_1)

plot(taux_chl, col = cluster_1$cluster,pch=16,cex=1.2,main="Regroupement par les k-means")

points(cluster_1$centers, col = 1:3, pch = 4,cex=2,lwd=3)

legend(x="topright", legend=unique(cluster_1$cluster), col=unique(cluster_1$cluster), pch=16)


```

