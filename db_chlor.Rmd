---
title: "Untitled"
author: "Pierre Chrislin DORIVAL"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
library(dplyr)
#install.packages("reshape2")
library(viridis)
#install.packages("RColorBrewer")
library(RColorBrewer)
#install.packages("fmsb")
library(fmsb)
library(ggplot2)
library(tidyr)
library(rstatix)
library(sf)
library(ggmap)
# Charger la librairie caret
library(caret)
library(stats)
library(reshape2)

```

```{r}
db_chlor = parcelles_chlordecone_janv21
db_chlor
```
```{r}
db_chlor = parcelles_chlordecone_janv21
# Extraire la première ligne comme noms de colonnes
noms_colonnes <- as.character(db_chlor[1, ])

# Remplacer les noms de colonnes
colnames(db_chlor) <- noms_colonnes

# Supprimer la première ligne des données
db_chlor <- db_chlor[-1, ]

rownames(db_chlor) <- NULL

# Afficher les premières lignes des données avec les nouveaux noms de colonnes
head(db_chlor)

```
```{r}
# Compter le nombre de valeurs NA dans la colonne COMMU_LAB
nb_na <- sum(is.na(db_chlor$COMMU_LAB))
nb_na



```




```{r}
colnames(db_chlor)
```
```{r}
db_chlor$COMMU_LAB[is.na(db_chlor$COMMU_LAB)] <- "COMMU_UN"
db_chlor <- subset(db_chlor, COMMU_LAB != "COMMU_UN")
supprimer_colonnes_na <- function(data) {
  # Identifier les colonnes avec au moins une valeur NA
  colonnes_a_supprimer <- names(data)[apply(data, 2, function(x) any(is.na(x)))]
  
  # Supprimer les colonnes identifiées
  data <- data[, !(names(data) %in% colonnes_a_supprimer)]
  
  return(data)
}



new_db_chlor <- supprimer_colonnes_na(db_chlor)


# Afficher les premières lignes des données après suppression des colonnes
new_db_chlor


```
```{r}

# Preparation des donnees
colnames(new_db_chlor)[colnames(new_db_chlor) == "pluviom\xe9trie_moyenne_annuelle"] <- "pluviometrie_moyenne_annuelle"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_mean"] <- "mnt.rugosite_mean"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_median"] <- "mnt.rugosite_median"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_stdev"] <- "mnt.rugosite_stdev"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_min"] <- "mnt.rugosite_min"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_max"] <- "mnt.rugosite_max"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_minority"] <- "mnt.rugosite_minority"
colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_majority"] <- "mnt.rugosite_majority"

colnames(new_db_chlor)[colnames(new_db_chlor) == "mnt.rugosit\xe9_variance"] <- "mnt.rugosite_variance"
colnames(new_db_chlor)[colnames(new_db_chlor) == "Ann\xe9e"] <- "Annee"
new_db_chlor$Adresse_parcelle <- iconv(new_db_chlor$Adresse_parcelle, from = "UTF-8", to = "ASCII", sub = "e")

new_db_chlor$pluviometrie_moyenne_annuelle <- gsub("-",  "+",new_db_chlor$pluviometrie_moyenne_annuelle)


# transformer les donnees dans la colonnes pulviometrie
moyennes <- numeric(length(new_db_chlor$pluviometrie_moyenne_annuelle))

# Diviser chaque valeur et calculer la moyenne
for(i in 1:length(new_db_chlor$pluviometrie_moyenne_annuelle)) {
    # Diviser la valeur en deux parties en utilisant le symbole '+'
    valeurs <- strsplit(new_db_chlor$pluviometrie_moyenne_annuelle[i], "\\+")
    # Convertir les parties en nombres et calculer la moyenne
    moyennes[i] <- mean(as.numeric(unlist(valeurs)))
}
new_db_chlor$Date_prelevement <- as.Date(new_db_chlor$Date_prelevement, format = "%d/%m/%Y")
# Ajouter la colonne de moyennes au jeu de données
new_db_chlor$moyenne_pulviometrie <- moyennes

new_db_chlor <- new_db_chlor[, !colnames(new_db_chlor) %in% c("Numero_sig", "ocs_gid", "ocs_code_us","ocs_ossature","ocs_code_cs","ocs_millesime","ocs_source","ocs_id_origine","ocs_code_or","Interet","pluviometrie_moyenne_annuelle","Operateur_5b","Operateur_chld")]

new_db_chlor <- na.omit(new_db_chlor)
# Écrire les données modifiées dans un nouveau fichier CSV
write.csv(new_db_chlor, "new_db_chlordecone.csv", row.names = FALSE)

```
```{r}

nlle_table <- new_db_chlordecone[, c("COMMU_LAB", "mnt.exposition_mean", "mnt.ombrage_mean","mnt.tri_mean","mnt.tpi_mean","Taux_chlordecone")] 
nlle_table$Taux_chlordecone <- as.numeric(nlle_table$Taux_chlordecone)

#nlle_table$mnt.ombrage_mean <- as.numeric(nlle_table$mnt.ombrage_mean)
nlle_table



```

```{r}
# Analyse statistiques


data_commu <- new_db_chlordecone[, c("COMMU_LAB", "Taux_chlordecone")]

# Agrégation des données par commune (calcul de la moyenne)
mean_commu <- aggregate(Taux_chlordecone ~ COMMU_LAB, data = data_commu, FUN = mean)



# Génération de 35 couleurs distinctes à partir de la palette
couleurs <- rainbow(35)
# Création du graphique (exemple avec un diagramme en barres)
barplot(mean_commu$Taux_chlordecone, 
        names.arg = mean_commu$COMMU_LAB, 
        col = couleurs, # Utilisation des couleurs variables
        xlab = "Commune", 
        ylab = "Taux moyen de chlordecone",
        main = "Répartition des taux de chlordecone par commune")

legend("topright", 
       legend = mean_commu$COMMU_LAB, 
       fill = couleurs, 
       title = "Communes",
       text.col = "black",   
       cex = 0.1) 
```
```{r}
unique(new_db_chlordecone$COMMU_LAB)
```

```{r}
# Création du graphique boxplot avec les données des taux de chlordecone par commune
boxplot(Taux_chlordecone ~ COMMU_LAB, data = data_commu, 
        xlab = "Commune", 
        ylab = "Taux de chlordecone",
        main = "Répartition des taux de chlordecone par commune")


```



```{r}
hist(mean_commu$Taux_chlordecone, 
     xlab = "Taux de chlordecone",
     ylab = "Fréquence",
     main = "Distribution des taux de chlordecone")
```
```{r}
colnames(new_db_chlordecone)
```
```{r}
nlle_table <- new_db_chlordecone[, c("COMMU_LAB", "Date_enregistrement", "Adresse_parcelle","Taux_chlordecone")] 
nlle_table

unique(new_db_chlordecone$Adresse_parcelle)
```
```{r}
new_db_chlordecone$Date_prelevement <- as.Date(new_db_chlordecone$Date_prelevement)




# Créer un résumé du nombre de parcelles par ville
res <- new_db_chlordecone %>% 
  group_by(COMMU_LAB) %>%
  summarize(Count = n())

# Tracer un diagramme en barres
ggplot(res, aes(x = reorder(COMMU_LAB, Count), y = Count)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(x = "Ville", y = "Nombre de parcelles", title = "Nombre de parcelles par ville") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_flip()

```
```{r}
res <- new_db_chlordecone %>%
  group_by(Date_prelevement) %>%
  summarize(Nombre_ID = n_distinct(ID))

# Tracer un graphique en barres
ggplot(res, aes(x = Date_prelevement, y = Nombre_ID)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(x = "Date de prélèvement", y = "Nombre d'ID", title = "Répartition des ID par date de prélèvement") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y")
```
```{r}
repetitions_ID_dates <- new_db_chlordecone %>%
  group_by(Annee, COMMU_LAB) %>%
  summarize(Count = n(), .groups = "drop")
repetitions_ID_dates
```
```{r}
```


```{r}
unique(new_db_chlordecone$Adresse_parcelle)

nombre_villes_par_annee <- new_db_chlordecone %>%
  distinct(Annee,Adresse_parcelle) %>%
  group_by(Annee) %>%
  summarize(Nombre_Villes_Uniques = n_distinct(Adresse_parcelle))
nombre_villes_par_annee

```
```{r}
combinaisons <- new_db_chlordecone %>%
  distinct(Annee, Adresse_parcelle)

# Créer une liste des villes pour chaque année
liste_villes_par_annee <- combinaisons %>%
  group_by(Annee) %>%
  summarize(Adresse_parcelle = paste(Adresse_parcelle, collapse = ", "))

# Afficher le résultat
liste_villes_par_annee
```

```{r}

# Filtrer les données pour la ville spécifique
donnees_ville <- subset(new_db_chlordecone, COMMU_LAB == "LAMENTIN(LE)")


ggplot(data = donnees_ville, aes(x = Annee, y = Taux_chlordecone)) +
  geom_line() +
  labs(title = "Variation des taux de chlordécone Lamentin", x = "Année", y = "Taux de chlordécone")

```
```{r}

ggplot(data = donnees_ville, aes(x = Annee, y = Taux_chlordecone)) +
  geom_bar(stat = "identity", fill = "blue") +
  labs(title = "Variation des taux de chlordécone Lamentin", x = "Année", y = "Taux de chlordécone")

```
```{r}
ggplot(data = donnees_ville, aes(x = Taux_chlordecone)) +
  geom_histogram(binwidth = 1, fill = "blue", color = "black") +
 facet_wrap(~Annee, scales = "free", ncol = 3) +
  labs(title = paste("Répartition des taux de chlordécone pour la ville", "LAMENTIN(LE)", "au fil des années"), x = "Taux de chlordécone", y = "Fréquence")
```
```{r}
# Création du modèle de régression
modele <- lm(Taux_chlordecone ~ Annee, data = new_db_chlordecone)

# Prédictions
predictions <- data.frame(Annee = rep(unique(new_db_chlordecone$Annee), length(unique(new_db_chlordecone$Adresse_parcelle))),
                         Adresse_parcelle = rep(unique(new_db_chlordecone$Adresse_parcelle), each = length(unique(new_db_chlordecone$Annee))))
predictions$Taux_chlordecone <- predict(modele, newdata = predictions)

# Chargement du package ggplot2
library(ggplot2)

# Création du graphique
graphique <- ggplot(data = new_db_chlordecone, aes(x = Annee, y = Taux_chlordecone, color = Adresse_parcelle)) +
  geom_point() +
  geom_line(data = predictions) +
  labs(title = "Répartition des taux de chlordécone pour commune au fil des années",
       x = "Année",
       y = "Taux de chlordécone",
       color = "Adresse_parcelle")
graphique
# Sauvegarde du graphique avec les dimensions spécifiées
#ggsave("nom_du_fichier.png", plot = graphique, width = 6, height = 4)
```
```{r}
# Création du modèle de régression
modele <- lm(Taux_chlordecone ~ Annee, data = new_db_chlordecone)

# Prédictions
predictions <- data.frame(Annee = rep(unique(new_db_chlordecone$Annee), length(unique(new_db_chlordecone$Adresse_parcelle))),
                         Adresse_parcelle = rep(unique(new_db_chlordecone$Adresse_parcelle), each = length(unique(new_db_chlordecone$Annee))))
predictions$Taux_chlordecone <- predict(modele, newdata = predictions)

# Tracé du graphique de régression
plot(new_db_chlordecone$Annee, new_db_chlordecone$Taux_chlordecone, 
     xlab = "Année", ylab = "Taux de chlordécone",
     main = "Répartition des taux de chlordécone pour commune au fil des années",
     col = "blue", pch = 20)
abline(modele, col = "red")  # Ajout de la ligne de régression

# Ajout de la légende
legend("topright", legend = "Régression linéaire", col = "red", lty = 1, cex = 0.8)


```
```{r}


# Diviser les données en ensembles d'entraînement et de test (par exemple, 70% pour l'entraînement et 30% pour les tests)
set.seed(123) # pour la reproductibilité
indices <- createDataPartition(new_db_chlordecone$Taux_chlordecone, p = 0.7, list = FALSE)
train <- new_db_chlordecone[indices, ]
test <- new_db_chlordecone[-indices, ]

# Créer le modèle de régression linéaire
modele <- lm(Taux_chlordecone ~ Annee, data = train)

# Afficher un résumé du modèle
summary(modele)
```
```{r}
# Faire des prédictions sur l'ensemble de test
predictions <- predict(modele, newdata = test)

# Calculer l'erreur quadratique moyenne (RMSE)
rmse <- sqrt(mean((predictions - test$Taux_chlordecone)^2))
print(paste("RMSE:", rmse))

```
```{r}
# Choix du nombre de clusters (k)
k <- 2  # Vous pouvez ajuster cette valeur selon votre contexte

# Sélection des variables pertinentes pour le clustering
donnees_clustering <- new_db_chlordecone[, c("Annee", "Taux_chlordecone")]

# Application de la méthode des k-moyennes
kmeans_resultats <- kmeans(donnees_clustering, centers = k)

# Affichage des résultats
print(kmeans_resultats)

# Visualisation des clusters
library(ggplot2)
ggplot(donnees_clustering, aes( x = Taux_chlordecone,y = Annee, color = factor(kmeans_resultats$cluster))) +
  geom_point() +
  labs(title = "Clustering des données de chlordécone",
       x = "Année",
       y = "Taux de chlordécone",
       color = "Cluster") +
  theme_minimal()
```

```{r}

k <- 3  # Vous pouvez ajuster cette valeur selon votre contexte

# Sélection des variables pertinentes pour le clustering
donnees_clustering <- new_db_chlordecone[, c( "Annee", "Taux_chlordecone")]

# Application de la méthode des k-moyennes
kmeans_resultats <- kmeans(donnees_clustering, centers = k)

# Affichage des résultats
print(kmeans_resultats)

# Visualisation des clusters
library(ggplot2)
ggplot(donnees_clustering, aes(x = Annee, y = Taux_chlordecone, color = factor(kmeans_resultats$cluster))) +
  geom_point() +
  labs(title = "Clustering des données de chlordécone",
       x = "Année",
       y = "Taux de chlordécone",
       color = "Cluster") +
  theme_minimal()
```


```{r}
plot(new_db_chlordecone$Annee, new_db_chlordecone$Taux_chlordecone, xlab = "Année", ylab = "Taux de chlordécone", type = "l")

# Graphique de la distribution des taux de chlordécone par commune
boxplot(Taux_chlordecone ~ COMMU_LAB, data = new_db_chlordecone, xlab = "Commune", ylab = "Taux de chlordécone")

```
```{r}


# Séparation des données pour chaque adresse de parcelle
adresses_parcelles <- unique(new_db_chlordecone$Adresse_parcelle)

# Initialisation d'une liste pour stocker les résultats
resultats <- list()

# Boucle sur chaque adresse de parcelle
for (adresse_parcelle in adresses_parcelles) {
  # Filtrer les données pour l'adresse de parcelle spécifique
  donnees_adresse <- subset(new_db_chlordecone, Adresse_parcelle == adresse_parcelle)
  
  # Calculer la moyenne du taux de chlordécone pour chaque année
  moyennes <- aggregate(Taux_chlordecone ~ Annee, data = donnees_adresse, FUN = mean)
  
  # Identifier les années où le taux de chlordécone augmente et diminue
  croissance <- diff(moyennes$Taux_chlordecone) > 0
  decroissance <- diff(moyennes$Taux_chlordecone) < 0
  
  # Stocker les résultats dans la liste
  resultats[[adresse_parcelle]] <- data.frame(Annee = moyennes$Annee[-1], Croissance = croissance, Decroissance = decroissance)
}

# Convertir la liste de résultats en un dataframe
resultats_df <- do.call(rbind, resultats)

# Regrouper les résultats pour le graphique
resultats_melt <- reshape2::melt(resultats_df, id.vars = "Annee", variable.name = "Type", value.name = "Valeur")

# Créer le graphique
ggplot(data = resultats_melt, aes(x = Annee, y = Valeur, color = Type)) +
  geom_line() +
  labs(title = "Évolution du taux de chlordécone par adresse de parcelle",
       x = "Année",
       y = "Valeur moyenne du taux de chlordécone") +
  scale_color_manual(values = c("blue", "red"),
                     labels = c("Croissance", "Décroissance")) +
  theme_minimal()

```

```{r}
# Filtrer les données pour une seule adresse de parcelle
adresse_selectionnee <- "Union"
donnees_adresse <- subset(new_db_chlordecone, Adresse_parcelle == adresse_selectionnee)

# Créer un graphique linéaire
ggplot(data = donnees_adresse, aes(x = Date_prelevement, y = Taux_chlordecone)) +
  geom_line() +
  labs(title = paste("Évolution du taux de chlordécone pour l'adresse de parcelle", adresse_selectionnee),
       x = "Année",
       y = "Taux de chlordécone") +
  theme_minimal()

ggplot(data = donnees_adresse, aes(x = Date_prelevement, y = Taux_chlordecone)) +
  geom_bar(stat = "identity") +
  labs(title = paste("Évolution du taux de chlordécone pour l'adresse de parcelle", adresse_selectionnee),
       x = "Année",
       y = "Taux de chlordécone") +
  theme_minimal()
```



```{r}

adresses_ville <- new_db_chlordecone$Adresse_parcelle[new_db_chlordecone$COMMU_LAB == "BASSE-POINTE"]
add_uniqe <- unique(adresses_ville)


```
```{r}

```

