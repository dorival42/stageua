---
title: "Analyses chlordecone en Martiniques"
author: "Pierre Chrislin DORIVAL"
date: "2024-04-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
library("corrplot")
library(dplyr)
#install.packages("purrr")
library(viridis)
#install.packages("ggpubr")
#install.packages("factoextra")
library(RColorBrewer)
#install.packages("fmsb")
library(fmsb)
library(ggplot2)
library(tidyr)
library(rstatix)
library(sf)
library(ggmap)
# Charger la librairie caret
library(caret)
library(stats)
library(reshape2)
library(purrr)
library(ggpubr)
library(factoextra)
```

```{r}


# Regrouper les données par commune et zone, et calculer les statistiques résumées
donnees_groupees <- new_db_chlordecone %>%
  group_by(COMMU_LAB, Adresse_parcelle, Annee) %>%
  summarise(
    Moyenne_Taux_chlordecone = mean(Taux_chlordecone),
    Ecart_type_Taux_chlordecone = sd(Taux_chlordecone),
    Nombre_prelevements = n()
  )

# Afficher les données regroupées
print(donnees_groupees)

```

```{r}

# Définir la fonction
tableau_commune_zone <- function(data, commune) {
  # Filtrer les données pour la commune spécifiée
  commune_data <- filter(data, COMMU_LAB == commune)
  
  # Regrouper les données par zone et calculer les statistiques résumées
  tableau <- commune_data %>%
    group_by(Adresse_parcelle) %>%
    summarise(
      Moyenne_Taux_chlordecone = mean(Taux_chlordecone),
      Ecart_type_Taux_chlordecone = sd(Taux_chlordecone),
      Nombre_prelevements = n()
    )
  
  # Afficher le tableau
  print(tableau)
}

# Utiliser la fonction avec le nom de la commune spécifiée
db_commune = tableau_commune_zone(new_db_chlordecone, "AJOUPA BOUILLON")

```
```{r}


# Grouper les données par commune et calculer le nombre total de prélèvements par commune
total_prelevements_par_commune <- new_db_chlordecone %>%
  group_by(COMMU_LAB) %>%
  summarize(Total_prelevements = n())
total_prelevements_par_commune 

# Sélectionner les communes avec au moins 60 % de prélèvements
communes_60_pourcent <- total_prelevements_par_commune %>%
  filter((Total_prelevements) >= 200) %>%
  select(COMMU_LAB)

# Filtrer les données initiales pour ne garder que les lignes des communes sélectionnées
nouvelle_table <- new_db_chlordecone %>%
  filter(COMMU_LAB %in% communes_60_pourcent$COMMU_LAB)
nouvelle_table
unique(nouvelle_table$COMMU_LAB)
```

```{r}
# Sélection des variables pour la classification
vars <- c("moyenne_pulviometrie", "mnt.exposition_mean", "mnt.ombrage_mean", "mnt.pente_mean", "mnt.tpi_mean","Taux_chlordecone")

# Normalisation des données
scaled_data <- scale(nouvelle_table[vars])

# Choix du nombre de clusters (vous pouvez ajuster ce paramètre selon vos besoins)
k <- 3

# Application de l'algorithme K-means
kmeans_result <- kmeans(scaled_data, centers = k)

# Ajout des étiquettes de cluster à vos données
nouvelle_table$Cluster <- as.factor(kmeans_result$cluster)

# Affichage des résultats
table(nouvelle_table$Cluster)


```

```{r}
fviz_cluster(kmeans_result, data = scaled_data,
             palette = c("#2E9FDF", "#00AFBB", "#E7B800"), 
             geom = "point",
             ellipse.type = "convex", 
             ggtheme = theme_bw()
             )
```


```{r}
# Réduction de dimension en utilisant l'ACP
res.pca <- prcomp(scaled_data,  scale = TRUE)
# Coordonnées des individus
ind.coord <- as.data.frame(get_pca_ind(res.pca)$coord)
# Ajouter les clusters obtenus à l'aide de l'algorithme k-means
ind.coord$cluster <- factor(kmeans_result$cluster)
res.pca


```
```{r}
eigenvalue <- round(get_eigenvalue(res.pca), 1)
variance.percent <- eigenvalue$variance.percent
head(eigenvalue)
```
```{r}
ggscatter(
  ind.coord, x = "Dim.1", y = "Dim.2", 
  color = "cluster", palette = "npg", ellipse = TRUE, ellipse.type = "convex",
   size = 1.5,  legend = "right", ggtheme = theme_bw(),
  xlab = paste0("Dim 1 (", variance.percent[1], "% )" ),
  ylab = paste0("Dim 2 (", variance.percent[2], "% )" )
) +
  stat_mean(aes(color = cluster), size = 4)
```


```{r}
fviz_eig(res.pca, addlabels = TRUE, ylim = c(0, 50))
# Color by cos2 values: quality on the factor map
fviz_pca_var(res.pca, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
             )

```
```{r}


var <- get_pca_var(res.pca)
var
corrplot(var$cos2, is.corr=FALSE)

```
```{r}
set.seed(123)
res.km <- kmeans(var$coord, centers = 3, nstart = 25)
grp <- as.factor(res.km$cluster)
# Color variables by groups
fviz_pca_var(res.pca, col.var = grp, 
             palette = c("#0073C2FF", "#EFC000FF", "#868086FF"),
             legend.title = "Cluster")
```
```{r}
# Exemple d'utilisation du test de Kolmogorov-Smirnov
x <- nouvelle_table$Taux_chlordecone
test_ks <- ks.test(x, "pnorm", mean = mean(x), sd = sd(x))  # Test si les données dans 'x' suivent une distribution normale

# Afficher les résultats du test
print(test_ks)

```

```{r}


# Regrouper les données par commune et calculer la moyenne du taux de chlordecone
moyennes_par_commune <- new_db_chlordecone %>%
  group_by(COMMU_LAB) %>%
  summarize(Moyenne_chlordecone = mean(Taux_chlordecone))

# Ajouter une colonne pour indiquer si la commune est contaminée à plus de 30 % ou moins
moyennes_par_commune$Contamination <- ifelse(moyennes_par_commune$Moyenne_chlordecone > 0.1, "ZONE avec plus de 10% contaminé", "ZONE avec moins de 10% contaminé")

# Afficher les premières lignes du tableau résultant
moyennes_par_commune

# Afficher la répartition des communes dans chaque catégorie de contamination
table(moyennes_par_commune$Contamination)
```

```{r}
# Supposons que votre dataframe s'appelle my_data et contient les variables COMMU_LAB (nom de la commune) et Taux_chlordecone

# Sélectionner uniquement les données nécessaires
donnees <-moyennes_par_commune[, c("COMMU_LAB", "Moyenne_chlordecone")]

# Définir le seuil de 10 % de contamination
seuil <- 0.1

# Appliquer la classification en deux clusters avec K-means
clusters <- kmeans(donnees$Moyenne_chlordecone, centers = 2)

# Ajouter les étiquettes de clusters à vos données
donnees$Cluster <- clusters$cluster

# Afficher la répartition des communes dans chaque cluster
table(donnees$Cluster)

# Visualiser les clusters
plot(donnees$Moyenne_chlordecone, col = clusters$cluster, 
     main = "Classification des communes en fonction du taux de chlordecone",
     xlab = "Communes", ylab = "Moyenne_chlordecone")
legend("topright", legend = c("Moins de 30% contaminé", "Plus de 30% contaminé"), col = 1:2, pch = 1)

```


```{r}
# Exemple de seuils pour la croissance et la décroissance
seuil_croissance <- 0.1  # Par exemple, toute observation avec un taux de chlordecone supérieur à 0.1 est considérée comme une croissance
seuil_decroissance <- -0.1  # Par exemple, toute observation avec un taux de chlordecone inférieur à -0.1 est considérée comme une décroissance

# Classification des données
new_db_chlordecone$Classification <- ifelse(new_db_chlordecone$Taux_chlordecone > seuil_croissance, "Croissance", 
                                 ifelse(new_db_chlordecone$Taux_chlordecone < seuil_decroissance, "Decroissance", "Stable"))

# Tableau résumé
table(new_db_chlordecone$Classification)

```

```{r}
barplot(table(new_db_chlordecone$Classification), 
        main = "Répartition des taux de chlordecone",
        xlab = "Classification",
        ylab = "Nombre d'observations")
```

```{r}


# Créer un graphique montrant le nombre de prélèvements par commune
ggplot(data = new_db_chlordecone, aes(x = COMMU_LAB)) +
  geom_bar(fill = "blue") +
  labs(title = "Nombre de prélèvements par commune",
       x = "Commune",
       y = "Nombre de prélèvements") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r}

#test statistique
modele <- aov(Taux_chlordecone ~ COMMU_LAB, data=new_db_chlordecone)
# Vérifier la normalité des résidus avec le test de Shapiro-Wilk

qqnorm(resid(modele))
qqline(resid(modele))
```
```{r}
# Calculer les résidus du modèle ANOVA
residus <- resid(modele)

# Tracer l'histogramme des résidus
hist(residus, main = "Histogramme des résidus", xlab = "Résidus", ylab = "Fréquence")

```

```{r}
# Appliquer une transformation log sur les résidus
residus_transformes <- log(residus + 1)

# Tracer l'histogramme des résidus transformés
hist(residus_transformes, main = "Histogramme des résidus transformés", xlab = "Résidus transformés", ylab = "Fréquence")



```
```{r}


# Appliquer le test de Levene pour vérifier l'homoscédasticité des résidus transformés
leveneTest(residus_transformes ~ COMMU_LAB, data = new_db_chlordecone)
```
Le résultat du test de Levene pour l'homogénéité des variances indique une forte significativité statistique avec une valeur de test F de 214.9 et une valeur p très faible, inférieure à 2.2e-16 (ce qui signifie essentiellement que la valeur p est très proche de zéro).

Cela suggère qu'il y a des différences significatives entre les variances des résidus entre les groupes (niveaux de la variable indépendante). En d'autres termes, l'hypothèse nulle d'homoscédasticité est rejetée, ce qui signifie que les variances des résidus ne sont pas constantes à travers tous les niveaux de la variable indépendante.

Lorsque le test de Levene est significatif, cela peut remettre en question l'interprétation des résultats de l'ANOVA. Dans ce cas, vous devrez peut-être utiliser des méthodes alternatives qui ne reposent pas sur l'hypothèse d'homoscédasticité, comme les tests robustes ou les méthodes de permutation, ou envisager des transformations supplémentaires des données pour stabiliser les variances. Vous pouvez également examiner de plus près les raisons potentielles de la violation de l'homoscédasticité, comme la présence de valeurs aberrantes ou la nécessité de modéliser des interactions supplémentaires.
```{r}
# Appliquer le test de Mann-Whitney
resultat_test <- wilcox.test(new_db_chlordecone$Taux_chlordecone, data = new_db_chlordecone)
# Appliquer le test de Welch
#resultat_test <- t.test(new_db_chlordecone$Taux_chlordecone, data = new_db_chlordecone, var.equal = FALSE)
resultat_test
```
```{r}
library(corrplot)
# L'Indice de Position Topographique (TPI)
# Calculer la matrice de corrélation entre les variables
correlation_matrix <- cor(new_db_chlordecone[c("Taux_chlordecone", "moyenne_pulviometrie", "mnt.exposition_mean", "mnt.ombrage_mean","mnt.pente_mean","mnt.tpi_mean" )])

# Afficher la matrice de corrélation
print(correlation_matrix)

# Afficher le graphe de la matrice de corrélation
corrplot(correlation_matrix, method = "circle", type = "upper", order = "hclust", tl.col = "black", tl.srt = 45)
```
```{r}
# Créer un modèle de régression linéaire
modele_regression <- lm(Taux_chlordecone ~ moyenne_pulviometrie + mnt.exposition_mean + mnt.ombrage_mean + mnt.pente_mean + mnt.tpi_mean, data = new_db_chlordecone)

# Afficher un résumé du modèle
summary(modele_regression)

# Tracer le graphique à partir du modèle de régression
plot(modele_regression)

```
```{r}
library(ggplot2)

# Créer une liste vide pour stocker les graphiques
plots <- list()

# Boucler à travers chaque commune unique
for (commune in unique(new_db_chlordecone$COMMU_LAB)) {
  # Subset des données pour la commune actuelle
  commune_data <- subset(new_db_chlordecone, COMMU_LAB == commune)
  
  # Créer un graphique en courbes pour la commune actuelle
  p <- ggplot(commune_data, aes(x = Annee, y = Taux_chlordecone)) +
    geom_line() +
    labs(title = paste("Dégradation du chlordecone pour", commune),
         x = "Année",
         y = "Taux de chlordecone") +
    theme_minimal()
  
  # Ajouter le graphique à la liste des graphiques
  plots[[commune]] <- p
}

# Afficher les graphiques
plots


```

```{r}
library(dplyr)

# Calculer le nombre de prélèvements par commune sur trois années différentes
nombre_prelevements <- aggregate(Annee ~ COMMU_LAB, data = new_db_chlordecone, FUN = function(x) length(unique(x)))

# Filtrer les communes avec un nombre de prélèvements sur trois années différentes supérieur à un seuil donné (par exemple, 10)
seuil <- 10
communes_a_conserver <- nombre_prelevements$COMMU_LAB[nombre_prelevements$Annee >= seuil]

# Filtrer les données pour ne conserver que les prélèvements des communes à conserver
plots_histogramme <- lapply(unique(new_db_chlordecone$COMMU_LAB), function(commune) {
  commune_data <- subset(new_db_chlordecone, COMMU_LAB == commune)
  p <- ggplot(commune_data, aes(x = Taux_chlordecone)) +
    geom_histogram(binwidth = 0.1, fill = "blue", color = "black") +
    labs(title = paste("Histogramme des préférences pour", commune),
         x = "Taux de chlordecone",
         y = "Fréquence") +
    theme_minimal()
  return(p)
})

# Afficher les histogrammes
plots_histogramme


```
```{r}
# Tracer les graphiques en courbes pour chaque commune séparément
plots <- lapply(unique(new_db_chlordecone$COMMU_LAB), function(commune) {
  commune_data <- subset(new_db_chlordecone, COMMU_LAB == commune)
  p <- ggplot(commune_data, aes(x = ANNEE, y = Taux_chlordecone)) +
    geom_line() +
    labs(title = paste("Dégradation du chlordecone pour", commune),
         x = "Année",
         y = "Taux de chlordecone") +
    theme_minimal()
  return(p)
})

# Afficher les graphiques
plots
```
```{r}
library(ggplot2)

# Tracer des graphiques en aire empilée pour chaque commune séparément
plots_aires_empilees <- lapply(unique(new_db_chlordecone$COMMU_LAB), function(commune) {
  commune_data <- subset(new_db_chlordecone, COMMU_LAB == commune)
  p <- ggplot(commune_data, aes(x = ANNEE, y = Taux_chlordecone, fill = ANNEE)) +
    geom_area() +
    labs(title = paste("Préférences en aire empilée pour", commune),
         x = "Année",
         y = "Taux de chlordecone") +
    theme_minimal()
  return(p)
})

# Afficher les graphiques
plots_aires_empilees

```
```{r}
library(ggplot2)

# Tracer un histogramme en barres regroupé pour les préférences par commune
ggplot(new_db_chlordecone, aes(x = COMMU_LAB, y = Taux_chlordecone, fill = ANNEE)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Histogramme en barres regroupées des préférences par commune",
       x = "Commune",
       y = "Taux de chlordecone") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotation des étiquettes de l'axe x pour une meilleure lisibilité

```
```{r}
```

