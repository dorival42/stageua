---
title: "Analyses chlordecone en Martiniques"
author: "Pierre Chrislin DORIVAL"
date: "2024-04-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r}
library(dplyr)

# Regrouper les données par commune et zone, et calculer les statistiques résumées
donnees_groupees <- new_db_chlordecone %>%
  group_by(COMMU_LAB, Adresse_parcelle, Annee) %>%
  summarise(
    Moyenne_Taux_chlordecone = mean(Taux_chlordecone),
    Ecart_type_Taux_chlordecone = sd(Taux_chlordecone),
    Nombre_prelevements = n()
  )

# Afficher les données regroupées
print(donnees_groupees)

```

```{r}
library(dplyr)

# Définir la fonction
tableau_commune_zone <- function(data, commune) {
  # Filtrer les données pour la commune spécifiée
  commune_data <- filter(data, COMMU_LAB == commune)
  
  # Regrouper les données par zone et calculer les statistiques résumées
  tableau <- commune_data %>%
    group_by(Adresse_parcelle) %>%
    summarise(
      Moyenne_Taux_chlordecone = mean(Taux_chlordecone),
      Ecart_type_Taux_chlordecone = sd(Taux_chlordecone),
      Nombre_prelevements = n()
    )
  
  # Afficher le tableau
  print(tableau)
}

# Utiliser la fonction avec le nom de la commune spécifiée
db_commune = tableau_commune_zone(new_db_chlordecone, "AJOUPA BOUILLON")

```
```{r}
# Tracer le graphe avec des couleurs pour chaque commune
ggplot(new_db_chlordecone, aes(x = ANNEE, y = Taux_chlordecone, color = COMMU_LAB)) +
  geom_line() +
  labs(title = "Évolution du chlordecone par commune",
       x = "Année",
       y = "Taux de chlordecone") +
  scale_color_discrete(name = "Commune")

```
```{r}
# Sélection des variables pour la classification
vars <- c("moyenne_pulviometrie", "mnt.exposition_mean", "mnt.ombrage_mean", "mnt.pente_mean", "mnt.tpi_mean","Taux_chlordecone")

# Normalisation des données
scaled_data <- scale(new_db_chlordecone[vars])

# Choix du nombre de clusters (vous pouvez ajuster ce paramètre selon vos besoins)
k <- 3

# Application de l'algorithme K-means
kmeans_result <- kmeans(scaled_data, centers = k)

# Ajout des étiquettes de cluster à vos données
new_db_chlordecone$Cluster <- as.factor(kmeans_result$cluster)

# Affichage des résultats
table(new_db_chlordecone$Cluster)


```

```{r}
# Nuage de points des deux premières variables avec couleur par cluster
plot(scaled_data[, 1], scaled_data[, 2], col = kmeans_result$cluster, 
     main = "Nuage de points avec couleur par cluster", 
     xlab = "Variable 1", ylab = "Variable 2")
legend("topright", legend = paste("Cluster", 1:k), col = 1:k, pch = 19, cex = 1)

```
```{r}
# Diagramme en boîte pour chaque variable par cluster
par(mfrow = c(1, length(vars)))
for (i in seq_along(vars)) {
  boxplot(new_db_chlordecone[[vars[i]]] ~ new_db_chlordecone$Cluster, main = paste("Diagramme en boîte de", vars[i]), xlab = "Cluster", ylab = vars[i])
}

```
```{r}
# Sélection des variables pour la PCA
vars <- c("moyenne_pulviometrie", "mnt.exposition_mean", "mnt.ombrage_mean", "mnt.pente_mean", "mnt.tpi_mean", "Taux_chlordecone")

# PCA
pca_result <- prcomp(new_db_chlordecone[vars], scale. = TRUE)  # Scale. = TRUE pour standardiser les variables

# Résumé de la PCA
summary(pca_result)

# Visualisation des résultats
biplot(pca_result, scale = 0)  # biplot pour afficher à la fois les variables et les individus sur le même graphique

```
```{r}
library(dplyr)

# Regrouper les données par commune et calculer la moyenne du taux de chlordecone
moyennes_par_commune <- new_db_chlordecone %>%
  group_by(COMMU_LAB) %>%
  summarize(Moyenne_chlordecone = mean(Taux_chlordecone))

# Ajouter une colonne pour indiquer si la commune est contaminée à plus de 30 % ou moins
moyennes_par_commune$Contamination <- ifelse(moyennes_par_commune$Moyenne_chlordecone > 0.1, "ZONE avec plus de 10% contaminé", "ZONE avec moins de 10% contaminé")

# Afficher les premières lignes du tableau résultant
moyennes_par_commune

# Afficher la répartition des communes dans chaque catégorie de contamination
table(moyennes_par_commune$Contamination)
```

```{r}
# Supposons que votre dataframe s'appelle my_data et contient les variables COMMU_LAB (nom de la commune) et Taux_chlordecone

# Sélectionner uniquement les données nécessaires
donnees <-moyennes_par_commune[, c("COMMU_LAB", "Moyenne_chlordecone")]

# Définir le seuil de 10 % de contamination
seuil <- 0.1

# Appliquer la classification en deux clusters avec K-means
clusters <- kmeans(donnees$Moyenne_chlordecone, centers = 2)

# Ajouter les étiquettes de clusters à vos données
donnees$Cluster <- clusters$cluster

# Afficher la répartition des communes dans chaque cluster
table(donnees$Cluster)

# Visualiser les clusters
plot(donnees$Moyenne_chlordecone, col = clusters$cluster, 
     main = "Classification des communes en fonction du taux de chlordecone",
     xlab = "Communes", ylab = "Moyenne_chlordecone")
legend("topright", legend = c("Moins de 30% contaminé", "Plus de 30% contaminé"), col = 1:2, pch = 1)

```


```{r}
# Exemple de seuils pour la croissance et la décroissance
seuil_croissance <- 0.1  # Par exemple, toute observation avec un taux de chlordecone supérieur à 0.1 est considérée comme une croissance
seuil_decroissance <- -0.1  # Par exemple, toute observation avec un taux de chlordecone inférieur à -0.1 est considérée comme une décroissance

# Classification des données
new_db_chlordecone$Classification <- ifelse(new_db_chlordecone$Taux_chlordecone > seuil_croissance, "Croissance", 
                                 ifelse(new_db_chlordecone$Taux_chlordecone < seuil_decroissance, "Decroissance", "Stable"))

# Tableau résumé
table(new_db_chlordecone$Classification)

```

```{r}
barplot(table(new_db_chlordecone$Classification), 
        main = "Répartition des taux de chlordecone",
        xlab = "Classification",
        ylab = "Nombre d'observations")
```

```{r}
library(ggplot2)

# Créer un graphique montrant le nombre de prélèvements par commune
ggplot(data = new_db_chlordecone, aes(x = COMMU_LAB)) +
  geom_bar(fill = "blue") +
  labs(title = "Nombre de prélèvements par commune",
       x = "Commune",
       y = "Nombre de prélèvements") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r}

#test statistique
modele <- aov(Taux_chlordecone ~ COMMU_LAB, data=new_db_chlordecone)
# Vérifier la normalité des résidus avec le test de Shapiro-Wilk

qqnorm(resid(modele))
qqline(resid(modele))
```
```{r}
# Calculer les résidus du modèle ANOVA
residus <- resid(modele)

# Tracer l'histogramme des résidus
hist(residus, main = "Histogramme des résidus", xlab = "Résidus", ylab = "Fréquence")

```

```{r}
# Appliquer une transformation log sur les résidus
residus_transformes <- log(residus + 1)

# Tracer l'histogramme des résidus transformés
hist(residus_transformes, main = "Histogramme des résidus transformés", xlab = "Résidus transformés", ylab = "Fréquence")



```
```{r}
#install.packages("car")

# Charger le package
#library(car)
# Appliquer le test de Levene pour vérifier l'homoscédasticité des résidus transformés
leveneTest(residus_transformes ~ COMMU_LAB, data = new_db_chlordecone)
```
Le résultat du test de Levene pour l'homogénéité des variances indique une forte significativité statistique avec une valeur de test F de 214.9 et une valeur p très faible, inférieure à 2.2e-16 (ce qui signifie essentiellement que la valeur p est très proche de zéro).

Cela suggère qu'il y a des différences significatives entre les variances des résidus entre les groupes (niveaux de la variable indépendante). En d'autres termes, l'hypothèse nulle d'homoscédasticité est rejetée, ce qui signifie que les variances des résidus ne sont pas constantes à travers tous les niveaux de la variable indépendante.

Lorsque le test de Levene est significatif, cela peut remettre en question l'interprétation des résultats de l'ANOVA. Dans ce cas, vous devrez peut-être utiliser des méthodes alternatives qui ne reposent pas sur l'hypothèse d'homoscédasticité, comme les tests robustes ou les méthodes de permutation, ou envisager des transformations supplémentaires des données pour stabiliser les variances. Vous pouvez également examiner de plus près les raisons potentielles de la violation de l'homoscédasticité, comme la présence de valeurs aberrantes ou la nécessité de modéliser des interactions supplémentaires.
```{r}
# Appliquer le test de Mann-Whitney
resultat_test <- wilcox.test(new_db_chlordecone$Taux_chlordecone, data = new_db_chlordecone)
# Appliquer le test de Welch
#resultat_test <- t.test(new_db_chlordecone$Taux_chlordecone, data = new_db_chlordecone, var.equal = FALSE)
resultat_test
```
```{r}
library(corrplot)
# L'Indice de Position Topographique (TPI)
# Calculer la matrice de corrélation entre les variables
correlation_matrix <- cor(new_db_chlordecone[c("Taux_chlordecone", "moyenne_pulviometrie", "mnt.exposition_mean", "mnt.ombrage_mean","mnt.pente_mean","mnt.tpi_mean" )])

# Afficher la matrice de corrélation
print(correlation_matrix)

# Afficher le graphe de la matrice de corrélation
corrplot(correlation_matrix, method = "circle", type = "upper", order = "hclust", tl.col = "black", tl.srt = 45)
```
```{r}
# Créer un modèle de régression linéaire
modele_regression <- lm(Taux_chlordecone ~ moyenne_pulviometrie + mnt.exposition_mean + mnt.ombrage_mean + mnt.pente_mean + mnt.tpi_mean, data = new_db_chlordecone)

# Afficher un résumé du modèle
summary(modele_regression)

# Tracer le graphique à partir du modèle de régression
plot(modele_regression)

```
```{r}
library(ggplot2)

# Créer une liste vide pour stocker les graphiques
plots <- list()

# Boucler à travers chaque commune unique
for (commune in unique(new_db_chlordecone$COMMU_LAB)) {
  # Subset des données pour la commune actuelle
  commune_data <- subset(new_db_chlordecone, COMMU_LAB == commune)
  
  # Créer un graphique en courbes pour la commune actuelle
  p <- ggplot(commune_data, aes(x = Annee, y = Taux_chlordecone)) +
    geom_line() +
    labs(title = paste("Dégradation du chlordecone pour", commune),
         x = "Année",
         y = "Taux de chlordecone") +
    theme_minimal()
  
  # Ajouter le graphique à la liste des graphiques
  plots[[commune]] <- p
}

# Afficher les graphiques
plots


```

```{r}
library(dplyr)

# Calculer le nombre de prélèvements par commune sur trois années différentes
nombre_prelevements <- aggregate(Annee ~ COMMU_LAB, data = new_db_chlordecone, FUN = function(x) length(unique(x)))

# Filtrer les communes avec un nombre de prélèvements sur trois années différentes supérieur à un seuil donné (par exemple, 10)
seuil <- 10
communes_a_conserver <- nombre_prelevements$COMMU_LAB[nombre_prelevements$Annee >= seuil]

# Filtrer les données pour ne conserver que les prélèvements des communes à conserver
plots_histogramme <- lapply(unique(data_filtree$COMMU_LAB), function(commune) {
  commune_data <- subset(data_filtree, COMMU_LAB == commune)
  p <- ggplot(commune_data, aes(x = Taux_chlordecone)) +
    geom_histogram(binwidth = 0.1, fill = "blue", color = "black") +
    labs(title = paste("Histogramme des préférences pour", commune),
         x = "Taux de chlordecone",
         y = "Fréquence") +
    theme_minimal()
  return(p)
})

# Afficher les histogrammes
plots_histogramme


```
```{r}
# Tracer les graphiques en courbes pour chaque commune séparément
plots <- lapply(unique(data_filtree$COMMU_LAB), function(commune) {
  commune_data <- subset(data_filtree, COMMU_LAB == commune)
  p <- ggplot(commune_data, aes(x = ANNEE, y = Taux_chlordecone)) +
    geom_line() +
    labs(title = paste("Dégradation du chlordecone pour", commune),
         x = "Année",
         y = "Taux de chlordecone") +
    theme_minimal()
  return(p)
})

# Afficher les graphiques
plots
```
```{r}
library(ggplot2)

# Tracer des graphiques en aire empilée pour chaque commune séparément
plots_aires_empilees <- lapply(unique(data_filtree$COMMU_LAB), function(commune) {
  commune_data <- subset(data_filtree, COMMU_LAB == commune)
  p <- ggplot(commune_data, aes(x = ANNEE, y = Taux_chlordecone, fill = ANNEE)) +
    geom_area() +
    labs(title = paste("Préférences en aire empilée pour", commune),
         x = "Année",
         y = "Taux de chlordecone") +
    theme_minimal()
  return(p)
})

# Afficher les graphiques
plots_aires_empilees

```
```{r}
library(ggplot2)

# Tracer un histogramme en barres regroupé pour les préférences par commune
ggplot(data_filtree, aes(x = COMMU_LAB, y = Taux_chlordecone, fill = ANNEE)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Histogramme en barres regroupées des préférences par commune",
       x = "Commune",
       y = "Taux de chlordecone") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotation des étiquettes de l'axe x pour une meilleure lisibilité

```
```{r}
data_filtree
```

