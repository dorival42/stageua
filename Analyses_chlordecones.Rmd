---
title: "Analyses chlordecone en Martiniques"
author: "Pierre Chrislin DORIVAL"
date: "2024-04-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
library("corrplot")
library(dplyr)
#install.packages("randomForest")
library(viridis)
#install.packages("ggpubr")
#install.packages("factoextra")
library(RColorBrewer)
#install.packages("fmsb")
library(fmsb)
library(ggplot2)
library(tidyr)
library(rstatix)
library(sf)
library(ggmap)
# Charger la librairie caret
library(caret)
library(stats)
library(reshape2)
library(purrr)
library(ggpubr)
library(factoextra)
```
```{r}
summary(new_db_chlordecone[, c("moyenne_pulviometrie","COMMU_LAB","mnt.exposition_mean","mnt.ombrage_mean","Taux_chlordecone")] )
```



```{r}

donnees_groupees <- new_db_chlordecone %>%
  group_by(COMMU_LAB, Adresse_parcelle, Annee) %>%
  summarise(
    Moyenne_Taux_chlordecone = mean(Taux_chlordecone),
    Ecart_type_Taux_chlordecone = sd(Taux_chlordecone),
    Nombre_prelevements = n(),
    .groups = "drop"  # Spécifier .groups pour éviter le message d'erreur
  )
# Afficher les données regroupées
print(donnees_groupees)

```


```{r}

# Définir la fonction
tableau_commune_zone <- function(data, commune) {
  # Filtrer les données pour la commune spécifiée
  commune_data <- filter(data, COMMU_LAB == commune)
  
  # Regrouper les données par zone et calculer les statistiques résumées
  tableau <- commune_data %>%
    group_by(Adresse_parcelle) %>%
    summarise(
      Moyenne_Taux_chlordecone = mean(Taux_chlordecone),
      Ecart_type_Taux_chlordecone = sd(Taux_chlordecone),
      Nombre_prelevements = n()
    )
  
  # Afficher le tableau
  print(tableau)
}

# Utiliser la fonction avec le nom de la commune spécifiée
db_commune = tableau_commune_zone(new_db_chlordecone, "AJOUPA BOUILLON")

```
```{r}


# Grouper les données par commune et calculer le nombre total de prélèvements par commune
total_prelevements_par_commune <- new_db_chlordecone %>%
  group_by(COMMU_LAB) %>%
  summarize(Total_prelevements = n())
total_prelevements_par_commune 

# Sélectionner les communes avec au moins 60 % de prélèvements
communes_60_pourcent <- total_prelevements_par_commune %>%
  filter((Total_prelevements) >= 200) %>%
  select(COMMU_LAB)

# Filtrer les données initiales pour ne garder que les lignes des communes sélectionnées
nouvelle_table <- new_db_chlordecone %>%
  filter(COMMU_LAB %in% communes_60_pourcent$COMMU_LAB)
nouvelle_table
unique(nouvelle_table$COMMU_LAB)
sum(total_prelevements_par_commune$Total_prelevements)
```

```{r}
# Sélection des variables pour la classification
vars <- c("moyenne_pulviometrie", "mnt.exposition_mean", "mnt.ombrage_mean", "mnt.pente_mean", "mnt.tpi_mean","Taux_chlordecone")

# Normalisation des données
scaled_data <- scale(nouvelle_table[vars])

# Choix du nombre de clusters (vous pouvez ajuster ce paramètre selon vos besoins)
k <- 3

# Application de l'algorithme K-means
kmeans_result <- kmeans(scaled_data, centers = k)

# Ajout des étiquettes de cluster à vos données
nouvelle_table$Cluster <- as.factor(kmeans_result$cluster)

# Affichage des résultats
table(nouvelle_table$Cluster)


```

```{r}
fviz_cluster(kmeans_result, data = scaled_data,
             palette = c("#2E9FDF", "#00AFBB", "#E7B800"), 
             geom = "point",
             ellipse.type = "convex", 
             ggtheme = theme_bw()
             )
```


```{r}
# Réduction de dimension en utilisant l'ACP
res.pca <- prcomp(scaled_data,  scale = TRUE)
# Coordonnées des individus
ind.coord <- as.data.frame(get_pca_ind(res.pca)$coord)
# Ajouter les clusters obtenus à l'aide de l'algorithme k-means
ind.coord$cluster <- factor(kmeans_result$cluster)
res.pca


```
```{r}
eigenvalue <- round(get_eigenvalue(res.pca), 1)
variance.percent <- eigenvalue$variance.percent
head(eigenvalue)
```
```{r}
ggscatter(
  ind.coord, x = "Dim.1", y = "Dim.2", 
  color = "cluster", palette = "npg", ellipse = TRUE, ellipse.type = "convex",
   size = 1.5,  legend = "right", ggtheme = theme_bw(),
  xlab = paste0("Dim 1 (", variance.percent[1], "% )" ),
  ylab = paste0("Dim 2 (", variance.percent[2], "% )" )
) +
  stat_mean(aes(color = cluster), size = 4)
```


```{r}
fviz_eig(res.pca, addlabels = TRUE, ylim = c(0, 50))
# Color by cos2 values: quality on the factor map
fviz_pca_var(res.pca, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
             )

```
```{r}


var <- get_pca_var(res.pca)
var
corrplot(var$cos2, is.corr=FALSE)

```
```{r}
set.seed(123)
res.km <- kmeans(var$coord, centers = 3, nstart = 25)
grp <- as.factor(res.km$cluster)
# Color variables by groups
fviz_pca_var(res.pca, col.var = grp, 
             palette = c("#0073C2FF", "#EFC000FF", "#868086FF"),
             legend.title = "Cluster")
```
```{r}
# Exemple d'utilisation du test de Kolmogorov-Smirnov
x <- nouvelle_table$Taux_chlordecone
test_ks <- ks.test(x, "pnorm", mean = mean(x), sd = sd(x))  # Test si les données dans 'x' suivent une distribution normale

# Afficher les résultats du test
print(test_ks)

```

```{r}


# Regrouper les données par commune et calculer la moyenne du taux de chlordecone
moyennes_par_commune <- new_db_chlordecone %>%
  group_by(COMMU_LAB) %>%
  summarize(Moyenne_chlordecone = mean(Taux_chlordecone))

# Ajouter une colonne pour indiquer si la commune est contaminée à plus de 30 % ou moins
moyennes_par_commune$Contamination <- ifelse(moyennes_par_commune$Moyenne_chlordecone > 0.1, "ZONE avec plus de 10% contaminé", "ZONE avec moins de 10% contaminé")

# Afficher les premières lignes du tableau résultant
moyennes_par_commune

# Afficher la répartition des communes dans chaque catégorie de contamination
table(moyennes_par_commune$Contamination)
```

```{r}
# Supposons que votre dataframe s'appelle my_data et contient les variables COMMU_LAB (nom de la commune) et Taux_chlordecone

# Sélectionner uniquement les données nécessaires
donnees <-moyennes_par_commune[, c("COMMU_LAB", "Moyenne_chlordecone")]

# Définir le seuil de 10 % de contamination
seuil <- 0.1

# Appliquer la classification en deux clusters avec K-means
clusters <- kmeans(donnees$Moyenne_chlordecone, centers = 2)

# Ajouter les étiquettes de clusters à vos données
donnees$Cluster <- clusters$cluster

# Afficher la répartition des communes dans chaque cluster
table(donnees$Cluster)

# Visualiser les clusters
plot(donnees$Moyenne_chlordecone, col = clusters$cluster, 
     main = "Classification des communes en fonction du taux de chlordecone",
     xlab = "Communes", ylab = "Moyenne_chlordecone")
legend("topright", legend = c("Moins de 30% contaminé", "Plus de 30% contaminé"), col = 1:2, pch = 1)

```


```{r}
# Exemple de seuils pour la croissance et la décroissance
seuil_croissance <- 0.1  # Par exemple, toute observation avec un taux de chlordecone supérieur à 0.1 est considérée comme une croissance
seuil_decroissance <- -0.1  # Par exemple, toute observation avec un taux de chlordecone inférieur à -0.1 est considérée comme une décroissance

# Classification des données
new_db_chlordecone$Classification <- ifelse(new_db_chlordecone$Taux_chlordecone > seuil_croissance, "Croissance", 
                                 ifelse(new_db_chlordecone$Taux_chlordecone < seuil_decroissance, "Decroissance", "Stable"))

# Tableau résumé
table(new_db_chlordecone$Classification)

```

```{r}
barplot(table(new_db_chlordecone$Classification), 
        main = "Répartition des taux de chlordecone",
        xlab = "Classification",
        ylab = "Nombre d'observations")
```

```{r}


# Créer un graphique montrant le nombre de prélèvements par commune
ggplot(data = new_db_chlordecone, aes(x = COMMU_LAB)) +
  geom_bar(fill = "blue") +
  labs(title = "Nombre de prélèvements par commune",
       x = "Commune",
       y = "Nombre de prélèvements") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r}

#test statistique
modele <- aov(Taux_chlordecone ~ COMMU_LAB, data=new_db_chlordecone)
# Vérifier la normalité des résidus avec le test de Shapiro-Wilk

qqnorm(resid(modele))
qqline(resid(modele))
```
```{r}

modele <- lm(Taux_chlordecone ~ moyenne_pulviometrie + mnt.exposition_mean + mnt.ombrage_mean + mnt.pente_mean + mnt.tpi_mean, data = new_db_chlordecone)

# Tracer le graphique Q-Q des résidus du modèle
qqnorm(resid(modele))
qqline(resid(modele))

```

```{r}
# Calculer les résidus du modèle ANOVA
residus <- resid(modele)

# Tracer l'histogramme des résidus
hist(residus, main = "Histogramme des résidus", xlab = "Résidus", ylab = "Fréquence")

```

```{r}
# Installer et charger le package "robustbase"
#install.packages("robustbase")
library(robustbase)

# Appliquer la régression linéaire robuste
modele_robuste <- lmrob(Taux_chlordecone ~ moyenne_pulviometrie + mnt.exposition_mean + mnt.ombrage_mean + mnt.pente_mean + mnt.tpi_mean, data = new_db_chlordecone)
summary(modele_robuste)

```


```{r}
# Appliquer une transformation log sur les résidus
residus_transformes <- log(residus + 1)

# Tracer l'histogramme des résidus transformés
hist(residus_transformes, main = "Histogramme des résidus transformés", xlab = "Résidus transformés", ylab = "Fréquence")



```
```{r}

#install.packages("car")
library(car)
library(carData)
# Appliquer le test de Levene pour vérifier l'homoscédasticité des résidus transformés
leveneTest(residus_transformes ~ COMMU_LAB, data = new_db_chlordecone)
```
Le résultat du test de Levene pour l'homogénéité des variances indique une forte significativité statistique avec une valeur de test F de 214.9 et une valeur p très faible, inférieure à 2.2e-16 (ce qui signifie essentiellement que la valeur p est très proche de zéro).

Cela suggère qu'il y a des différences significatives entre les variances des résidus entre les groupes (niveaux de la variable indépendante). En d'autres termes, l'hypothèse nulle d'homoscédasticité est rejetée, ce qui signifie que les variances des résidus ne sont pas constantes à travers tous les niveaux de la variable indépendante.

Lorsque le test de Levene est significatif, cela peut remettre en question l'interprétation des résultats de l'ANOVA. Dans ce cas, vous devrez peut-être utiliser des méthodes alternatives qui ne reposent pas sur l'hypothèse d'homoscédasticité, comme les tests robustes ou les méthodes de permutation, ou envisager des transformations supplémentaires des données pour stabiliser les variances. Vous pouvez également examiner de plus près les raisons potentielles de la violation de l'homoscédasticité, comme la présence de valeurs aberrantes ou la nécessité de modéliser des interactions supplémentaires.
```{r}
library(ggplot2)

# Diagramme à boîtes par commune
ggplot(new_db_chlordecone, aes(x = as.factor(COMMU_LAB), y = Taux_chlordecone)) +
  geom_boxplot() +
  xlab("Commune") +
  ylab("Taux de Chlordecone") +
  ggtitle("Distribution des Taux de Chlordecone par Commune") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# Modèle de régression
modele <- lm(Taux_chlordecone ~ moyenne_pulviometrie + mnt.exposition_mean + mnt.ombrage_mean + mnt.pente_mean + mnt.tpi_mean, data = new_db_chlordecone)

# Résidus vs valeurs ajustées
residus <- resid(modele)
valeurs_ajustees <- fitted(modele)

ggplot(data = data.frame(residus, valeurs_ajustees), aes(x = valeurs_ajustees, y = residus)) +
  geom_point() +
  geom_smooth(method = "loess", se = FALSE, color = "red") +
  xlab("Valeurs Ajustées") +
  ylab("Résidus") +
  ggtitle("Résidus vs Valeurs Ajustées") +
  theme_minimal()

```


```{r}
# Appliquer le test de Mann-Whitney
wilcox_test <- wilcox.test(new_db_chlordecone$Taux_chlordecone, mu = 0, correct = TRUE)
# Appliquer le test de Welch
#resultat_test <- t.test(new_db_chlordecone$Taux_chlordecone, data = new_db_chlordecone, var.equal = FALSE)
#resultat_test
wilcox_test
```
```{r}
library(corrplot)

# Calculer la matrice de corrélation entre les variables
correlation_matrix <- cor(new_db_chlordecone[c("Taux_chlordecone", "moyenne_pulviometrie", "mnt.exposition_mean", "mnt.ombrage_mean","mnt.pente_mean","mnt.tpi_mean" )])

# Afficher la matrice de corrélation
print(correlation_matrix)

# Afficher le graphe de la matrice de corrélation
corrplot(correlation_matrix, method = "circle", type = "upper", order = "hclust", tl.col = "black", tl.srt = 45)
```
```{r}


# Filtrer les communes ayant des prélèvements sur trois années différentes
nombre_prelevements <- new_db_chlordecone %>%
  group_by(COMMU_LAB) %>%
  summarize(annees = n_distinct(ANNEE))



# Calculer et afficher la matrice de corrélation pour chaque commune
unique_communes <- unique(new_db_chlordecone$COMMU_LAB)

for (commune in unique_communes) {
  commune_data <- new_db_chlordecone %>%
    filter(COMMU_LAB == commune)
  

  
  if (nrow(commune_data) > 1) {  # Vérifier qu'il y a plus d'une ligne pour calculer la corrélation
    correlation_matrix <- cor(commune_data[c("Taux_chlordecone", "moyenne_pulviometrie", "mnt.exposition_mean", "mnt.ombrage_mean", "mnt.pente_mean", "mnt.tpi_mean")], use = "complete.obs")
    
if (any(is.na(correlation_matrix))) {
      next  # Ignorer cette commune si la matrice de corrélation contient des NA
    }
    
    print(paste("Matrice de corrélation pour la commune:", commune))
    print(correlation_matrix)
    
    # Afficher le graphe de la matrice de corrélation
    corrplot(correlation_matrix, method = "circle", type = "upper", order = "hclust", 
             tl.col = "black", tl.srt = 45, title = paste("Corrélation -", commune))
  }
}

```
```{r}
data_clean <- new_db_chlordecone %>%
  mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))

# Normalisation des données
data_normalized <- scale(data_clean[, c("Taux_chlordecone", "moyenne_pulviometrie", "mnt.exposition_mean", "mnt.ombrage_mean", "mnt.pente_mean", "mnt.tpi_mean")])

summary(data_normalized)
```

```{r}
# Appliquer l'algorithme K-means
set.seed(123) # Pour la reproductibilité
kmeans_result <- kmeans(data_normalized, centers = 3)
kmeans_result
# Visualiser les clusters
fviz_cluster(kmeans_result, data = data_normalized, geom = "point")

```

```{r}


# Convertir la colonne 'adresse_parcelle' en facteur
new_db_chlordecone$Adresse_parcelle <- factor(new_db_chlordecone$Adresse_parcelle)

# Convertir les facteurs en valeurs numériques
new_db_chlordecone$Adresse_parcelle_numeric <- as.numeric(new_db_chlordecone$Adresse_parcelle)
new_db_chlordecone$Adresse_parcelle_numeric
# Sélectionner les colonnes pertinentes pour le clustering
cluster_data <- new_db_chlordecone %>%
  select(Adresse_parcelle_numeric, Taux_chlordecone, moyenne_pulviometrie, mnt.exposition_mean, mnt.ombrage_mean, mnt.pente_mean, mnt.tpi_mean)

# Transformer les données catégorielles en variables numériques si nécessaire
# Ici, je suppose que 'adresse_parcelle' est déjà numérique. Si ce n'est pas le cas, utilisez des techniques d'encodage appropriées.

# Normalisation des données
scaled_data <- scale(cluster_data[, -1])  # Exclure la colonne 'adresse_parcelle'

# Appliquer l'algorithme de clustering
kmeans_result <- kmeans(scaled_data, centers = 3)

# Visualiser les clusters
fviz_cluster(kmeans_result, data = scaled_data)

# Interpréter les clusters

```

```{r}
# Ajouter la colonne adresse_parcelle aux résultats de clustering
cluster_results <- cbind(cluster_data, Cluster = kmeans_result$cluster, Adresse_parcelle = new_db_chlordecone$Adresse_parcelle)

# Trier les résultats par cluster et par taux de chlordecone décroissant
sorted_results <- cluster_results[order(cluster_results$Cluster, -cluster_results$Taux_chlordecone), ]

# Afficher les noms des parcelles les plus contaminées dans chaque cluster
for (i in unique(sorted_results$Cluster)) {
  cat("Cluster", i, ":\n")
  cat(head(sorted_results$Adresse_parcelle[sorted_results$Cluster == i], 5), "\n")
  cat("\n")
}


```



```{r}
# Charger les bibliothèques nécessaires
library(ggplot2)
library(factoextra)
library(dplyr)

# Filtrer les communes ayant des prélèvements sur trois années différentes
nombre_prelevements <- new_db_chlordecone %>%
  group_by(COMMU_LAB) %>%
  summarize(annees = n_distinct(ANNEE))

seuil <- 3
communes_a_conserver <- nombre_prelevements %>%
  filter(annees >= seuil) %>%
  pull(COMMU_LAB)

data_filtree <- new_db_chlordecone %>%
  filter(COMMU_LAB %in% communes_a_conserver)

# Calculer la tendance du taux de chlordecone pour chaque ville
tendances <- data_filtree %>%
  group_by(COMMU_LAB) %>%
  summarize(tendance = coef(lm(Taux_chlordecone ~ ANNEE, data = .))[2])
print(tendances)
# Vérifier le nombre de points de données distincts
distinct_points <- length(unique(tendances$tendance))

# Ajuster le nombre de clusters en fonction du nombre de points distincts
num_clusters <- min(3, distinct_points)

# Effectuer le clustering sur les tendances
set.seed(123)  # Pour la reproductibilité
km_res <- kmeans(tendances$tendance, centers = num_clusters)

# Ajouter les résultats du clustering aux données
tendances$cluster <- km_res$cluster

# Visualiser les clusters
fviz_cluster(list(data = tendances, cluster = km_res$cluster),
             geom = "point",
             stand = FALSE,
             ellipse = TRUE,
             show.clust.cent = TRUE,
             ggtheme = theme_minimal())

# Afficher les résultats des clusters
print(tendances)



```

```{r}
# Créer un modèle de régression linéaire
modele_regression <- lm(Taux_chlordecone ~ moyenne_pulviometrie + mnt.exposition_mean + mnt.ombrage_mean + mnt.pente_mean + mnt.tpi_mean, data = new_db_chlordecone)

# Afficher un résumé du modèle
summary(modele_regression)

# Tracer le graphique à partir du modèle de régression
plot(modele_regression)

```
```{r}
library(ggplot2)

# Créer une liste vide pour stocker les graphiques
plots <- list()

# Boucler à travers chaque commune unique
for (commune in unique(new_db_chlordecone$COMMU_LAB)) {
  # Subset des données pour la commune actuelle
  commune_data <- subset(new_db_chlordecone, COMMU_LAB == commune)
  
  # Créer un graphique en courbes pour la commune actuelle
  p <- ggplot(commune_data, aes(x = Annee, y = Taux_chlordecone)) +
    geom_line() +
    labs(title = paste("Dégradation du chlordecone pour", commune),
         x = "Année",
         y = "Taux de chlordecone") +
    theme_minimal()
  
  # Ajouter le graphique à la liste des graphiques
  plots[[commune]] <- p
}

# Afficher les graphiques
plots


```

```{r}
library(dplyr)

# Calculer le nombre de prélèvements par commune sur trois années différentes
nombre_prelevements <- aggregate(Annee ~ COMMU_LAB, data = new_db_chlordecone, FUN = function(x) length(unique(x)))

# Filtrer les communes avec un nombre de prélèvements sur trois années différentes supérieur à un seuil donné (par exemple, 10)
seuil <- 10
communes_a_conserver <- nombre_prelevements$COMMU_LAB[nombre_prelevements$Annee >= seuil]

# Filtrer les données pour ne conserver que les prélèvements des communes à conserver
plots_histogramme <- lapply(unique(new_db_chlordecone$COMMU_LAB), function(commune) {
  commune_data <- subset(new_db_chlordecone, COMMU_LAB == commune)
  p <- ggplot(commune_data, aes(x = Taux_chlordecone)) +
    geom_histogram(binwidth = 0.1, fill = "blue", color = "black") +
    labs(title = paste("Histogramme des préférences pour", commune),
         x = "Taux de chlordecone",
         y = "Fréquence") +
    theme_minimal()
  return(p)
})

# Afficher les histogrammes
plots_histogramme


```
```{r}
# Tracer les graphiques en courbes pour chaque commune séparément
plots <- lapply(unique(new_db_chlordecone$COMMU_LAB), function(commune) {
  commune_data <- subset(new_db_chlordecone, COMMU_LAB == commune)
  p <- ggplot(commune_data, aes(x = ANNEE, y = Taux_chlordecone)) +
    geom_line() +
    labs(title = paste("Dégradation du chlordecone pour", commune),
         x = "Année",
         y = "Taux de chlordecone") +
    theme_minimal()
  return(p)
})

# Afficher les graphiques
plots
```
```{r}
library(ggplot2)

# Tracer des graphiques en aire empilée pour chaque commune séparément
plots_aires_empilees <- lapply(unique(new_db_chlordecone$COMMU_LAB), function(commune) {
  commune_data <- subset(new_db_chlordecone, COMMU_LAB == commune)
  p <- ggplot(commune_data, aes(x = ANNEE, y = Taux_chlordecone, fill = ANNEE)) +
    geom_area() +
    labs(title = paste("Préférences en aire empilée pour", commune),
         x = "Année",
         y = "Taux de chlordecone") +
    theme_minimal()
  return(p)
})

# Afficher les graphiques
plots_aires_empilees

```
```{r}
library(ggplot2)

# Tracer un histogramme en barres regroupé pour les préférences par commune
ggplot(new_db_chlordecone, aes(x = COMMU_LAB, y = Taux_chlordecone, fill = ANNEE)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Histogramme en barres regroupées des préférences par commune",
       x = "Commune",
       y = "Taux de chlordecone") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotation des étiquettes de l'axe x pour une meilleure lisibilité

```
```{r}
library(MASS)
library(car)
library(cluster)
library(factoextra)
library(dplyr)

# Supposons que vos données soient dans un dataframe nommé 'new_db_chlordecone'

# Vérification et traitement des valeurs infinies et manquantes
new_db_chlordecone <- new_db_chlordecone %>%
  mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))) %>%
  mutate(across(everything(), ~ ifelse(is.infinite(.), mean(., na.rm = TRUE), .)))

# Normalisation des données
data_normalized <- scale(new_db_chlordecone[, c("Taux_chlordecone", "moyenne_pulviometrie", "mnt.exposition_mean", "mnt.ombrage_mean", "mnt.pente_mean", "mnt.tpi_mean")])

# Ajout de la colonne Adresse_parcelle_numeric (supposons que c'est déjà fait)
data_normalized <- cbind(data_normalized, Adresse_parcelle_numeric = new_db_chlordecone$Adresse_parcelle_numeric)

# Réaliser le clustering k-means avec un nombre d'itérations augmenté
set.seed(123)
kmeans_result <- kmeans(data_normalized, centers = 3, nstart = 25, iter.max = 1000)

# Afficher les résultats
print(kmeans_result)

# Visualiser les clusters
fviz_cluster(kmeans_result, data = data_normalized, geom = "point", ellipse.type = "convex", ggtheme = theme_minimal())

# Ajouter les noms des parcelles aux clusters
new_db_chlordecone$Cluster <- kmeans_result$cluster

# Identifier les parcelles les plus contaminées dans chaque cluster
parcelles_contaminees <- new_db_chlordecone %>%
  group_by(Cluster) %>%
  top_n(10, Taux_chlordecone) %>%
  select(Cluster, Adresse_parcelle, Taux_chlordecone)

print(parcelles_contaminees)

```

